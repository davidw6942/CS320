# CS320

				David Wasson	
		CS 320 Project Two Submission: Summary and Reflections Report
				Southern New Hampshire University
					Professor Lou
					12/20/24

					Summary
The testing approach for each began in a similar fashion. I first double checked the requirements for each feature to make sure I felt comfortable with the code I had produced. Each feature was required to have similar functionality with the ability to add, delete, or update information. In the task class one requirement was that the task object shall have a required description String field that cannot be longer than 50 characters, and the description field shall not be null. To meet this requirement, I came up with the following code:
if (description == null || description.length() > 50) {
            throw new IllegalArgumentException("Task description can't be null and has to be less than 50 characters.");
        }
This outlines the exact requirement set forth in this example. However, just because something appears to be correct doesn’t mean that functions as intended. Testing is very important for that reason. I’m very new to testing, but it makes sense that we would want to find any defects before we get too far along. In the test for task I used the following code to ensure this requirement was met and worked properly:
public void testTaskCreationInvalidDescription() {
        assertThrows(IllegalArgumentException.class, () -> new Task("task1", "Name", "The description has to be less than 50 characters long this is too long for a description"));        
    }
Considering the attention to detail in the task class and the execution of the test, I feel that the test class performed very well. I was able to come up with tests that not only tested for functionality but would also give an indication of where and why the error occurred. This is important as it could save a lot of time and effort in finding the error to even begin to fix it. Additionally, someone else could come into the code, find the correlation between the base class and the test class, and feel comfortable updating or expanding it for the future. 
					Reflection
The main technique used for the project was unit testing and exception testing. Unit testing provided a method to test each individual requirement for each feature requested by the client. This method was clear to me the best way to ensure that the features met the client’s requirements logically and allowed each feature to be tested very well before integrating together in the system. Exception testing was also essential to meet the requirements of the client. Not only did I want to find out what was going wrong, I wanted to keep the users in mind when something went wrong. Having a user-friendly way of letting the user know where the problem is was a great touch and kept the system at a stable level when an error occurred. A technique that I didn’t use during this project was integration testing. While integration testing would be a great strategy when it comes time to put everything together, for this project it was better to focus on individual functionality. If that time were to have come during this project, it would be practical to use this method to ensure that all of the features worked together correctly and seamlessly. 
					Mindset	
During this project my mindset was very cautious to ensure that each feature met the requirements of the customer and that the tests I created were thoroughly testing each feature. Using the feedback provided to me, I was able to navigate the happy and negative cases that occurred in testing while explaining to the user what the problem was. This helped to bring together the complexity of the relationships in each unit. A good example of this would be testing for when an appointment date was null when scheduling a new appointment. The code is as follows:
public void testNullAppointmentDate() {
        assertThrows(IllegalArgumentException.class, () -> {
            new Appointment("I1224", null, "Date can't be null");
        });
This can be seen as a small mistake. However, if this isn’t caught the entry for this appointment can have negative effects on the other features and create a negative experience for a customer. This aligns with maintaining business logic for the system. 
I find its easy for anyone to be biased towards a project that they planned out and worked so hard on. However, if I just assume everything is correct, there could be critical errors in the code that makes it unstable and fails to meet the functional requirements the client requests. To limit my bias, I wrote the test with the assumption that my code wasn’t perfect. That there could be many errors present. Therefore, I made sure that I really tested my code and had a way to handle any exceptions. In the development role, this did help me realize how detrimental it would be for me or anyone to test their own code. At first, I found it difficult to flip that switch when I first completed my code. Then when I first ran a test and found an error it was like I could finally see the other side. I was able to take off my tinted glasses and see my code for what it was. 
Being disciplined is something many of us struggle with in many aspects of life. Whether it be following a diet, work out plan, cleaning our homes or coding. Whenever we find a task to be tedious or repetitive, we tend to cut corners. The unintended consequences of cutting corners can be catastrophic. In coding when we cut corners even the smallest of bugs can develop into a large-scale issue when rolling out software. I intend to make a commitment to quality as I become a practitioner in the field. To do this I will make the most out of the time I spend planning a project. I will make it a point to be proactive when seeking requirements and feedback from a client. I also will never assume that just because the code looks good that it will work like it should and integrate into the larger system like it should. If I gather a requirement from a client that wants the program to be able add a name to a database while requiring the name to be no more than 20 characters and it can’t be null, I will make sure the code I write will be thought out to only allow the name to be no more than 20 characters and not null. I will put my bias aside while also keeping some thought from a tester perspective. 

